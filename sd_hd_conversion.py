# -*- coding: utf-8 -*-
"""SD_HD_CONVERSION

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/sd-hd-conversion-071eb3d7-61bf-4569-b6b5-0fae780bb3e1.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240801/auto/storage/goog4_request%26X-Goog-Date%3D20240801T100422Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D1004c442fbba04e28b2f2f8f0f328322dd70d5b2105cd49e899847bda3542c91cd3d96ea5d8c55acfc2d3dd4f3ac5f83962d64674dd839ab193dbc20ac4cd8b4fe03db332a8f16f3cc9e171c401f8b75b4bab7a2a31c0ebda77b4033b0768655a66dd991dceb9b1a39f7096e25c94544d09ba229b6296109d512263630a839b6ba8ab2529bca470f0e3551b03ee9573f635d5ee545988c094c456d3ddb84e996ebc7c6ac64238483a1c1833c6ad60cba0a626667d5d513c355df38d37b8865347a04bcd03fe55f50983c794a89e692dabf3cf0cd5919ef38bd06ba08bcbdf6ce5a8de5b040e62fea3bb7b0bd2d8d027cf5f74848a6baab8ff97ac42d0f45c561
"""

import cv2
import numpy as np
import torch
from PIL import Image
import tqdm as tqdm
import warnings
warnings.filterwarnings("ignore")

!pip install -qq -U diffusers transformers ftfy accelerate

import torch
from diffusers import AutoPipelineForInpainting
from diffusers.utils import load_image, make_image_grid

pipeline = AutoPipelineForInpainting.from_pretrained(
    "runwayml/stable-diffusion-inpainting", torch_dtype=torch.float16,variant="fp16"
)
pipeline.enable_model_cpu_offload()

def pad_resize(frame, target_width=1280, target_height=720):
    org_height, org_width = frame.shape[:2]
    scale = min(target_height / org_height, target_width / org_width)

    new_width = int(org_width * scale)
    new_height = int(org_height * scale)

    resized_frame = cv2.resize(frame, (new_width, new_height))
    new_frame = np.zeros((target_height, target_width, 3), dtype=np.uint8)

    y_offset = (target_height - new_height) // 2
    x_offset = (target_width - new_width) // 2
    new_frame[y_offset:y_offset + new_height, x_offset:x_offset + new_width] = resized_frame

    return new_frame, x_offset, new_width

def inpaint_frame(frame, mask, pipeline):
    # frame and mask are resized to 512x512 for inpainting
    frame_resized = cv2.resize(frame, (512, 512))
    mask_resized = cv2.resize(mask, (512, 512))

    frame_image = Image.fromarray(frame_resized)
    mask_image = Image.fromarray(mask_resized)

    try:
        inpainted_frame = pipeline(prompt=" ", image=frame_image, mask_image=mask_image).images[0]

        # Resizing inpainted frame back to original size
        inpainted_frame = inpainted_frame.resize((frame.shape[1], frame.shape[0]))
        return np.array(inpainted_frame)
    except Exception as e:
        print(f"Error in inpainting frame: {e}")
        return frame

def extract_frames(video_path):
    cap = cv2.VideoCapture(video_path)
    frames = []
    while cap.isOpened():
        ret, frame = cap.read()
        if ret:
            frames.append(frame)
        else:
            break
    cap.release()
    return frames

def reconstruct_video(frames, output_video_path, fps=2):
    height, width, _ = frames[0].shape
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter(output_video_path, fourcc, fps, (width, height))
    for frame in frames:
        out.write(frame)
    out.release()

def converter(input_video, output_video, frame_rate_reduction=1):

    frames = extract_frames(input_video)

    inpainted_frames = []
    for i, frame in enumerate(frames):
        if i % frame_rate_reduction == 0:  # Process frames based on reduction
            padded_frame, start_x, new_width = pad_resize(frame)
            mask = np.zeros_like(padded_frame[:, :, 0])
            mask[:, :start_x] = 1
            mask[:, start_x + new_width:] = 1
            inpainted_frame = inpaint_frame(padded_frame, mask, pipeline)
            inpainted_frames.append(inpainted_frame)

    if not output_video.endswith('.mp4'):
        output_video += '.mp4'
    reconstruct_video(inpainted_frames, output_video)
    return output_video

converter("/kaggle/input/orange/input_lion_2.mp4","/kaggle/working/output_lion_2.mp4")

FRAMES=extract_frames("/kaggle/input/orange/input_lion_2.mp4")
fr=extract_frames("/kaggle/working/output_lion_2.mp4")
print(len(FRAMES))
print(len(fr))
for i in fr:
    print(i.shape)

"""###"""

